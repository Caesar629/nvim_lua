/*!
 * coc-tasks v0.3.1
 * https://github.com/voldikss/coc-tasks
 * Released under the MIT License.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coc_nvim = require('coc.nvim');

const ASYNCTASKS_MACROS = {
    VIM_FILEPATH: {
        description: 'File name of current buffer with full path',
        example: '/home/voldikss/naiveproject/main.c',
    },
    VIM_FILENAME: {
        description: 'File name of current buffer without path',
        example: 'main.c',
    },
    VIM_FILEDIR: {
        description: 'Full path of current buffer without the file name',
        example: '/home/voldikss/naiveproject',
    },
    VIM_FILEEXT: {
        description: 'File extension of current buffer',
        example: '.c',
    },
    VIM_FILETYPE: {
        description: 'File type (value of &ft in vim)',
        example: 'c',
    },
    VIM_FILENOEXT: {
        description: 'File name of current buffer without path and extension',
        example: 'main',
    },
    VIM_PATHNOEXT: {
        description: 'Current file name with full path but without extension',
        example: '/home/voldikss/naiveproject/main',
    },
    VIM_CWD: {
        description: 'Current directory',
        example: '/home/voldikss/naiveproject',
    },
    VIM_RELDIR: {
        description: 'File path relativize to current directory',
        example: '.',
    },
    VIM_RELNAME: {
        description: 'File name relativize to current directory',
        example: 'main.c',
    },
    VIM_CWORD: {
        description: 'Current word under cursor',
        example: '',
    },
    VIM_CFILE: {
        description: 'Current filename under cursor',
        example: '',
    },
    VIM_CLINE: {
        description: 'Cursor line number in current buffer',
        example: '',
    },
    VIM_VERSION: {
        description: 'Value of v:version',
        example: '800',
    },
    VIM_SVRNAME: {
        description: 'Value of v:servername for +clientserver usage',
        example: '/tmp/nvimfOsenC/0',
    },
    VIM_COLUMNS: {
        description: "How many columns in vim's screen",
        example: '',
    },
    VIM_LINES: {
        description: "How many lines in vim's screen",
        example: '',
    },
    VIM_GUI: {
        description: 'Is running under gui ?',
        example: '',
    },
    VIM_ROOT: {
        description: 'Project root directory',
        example: '/home/voldikss/naiveproject',
    },
    VIM_DIRNAME: {
        description: 'Name of current directory',
        example: 'naiveproject',
    },
    VIM_PRONAME: {
        description: 'Name of current project root directory',
        example: 'naiveproject',
    },
    VIM_PROFILE: {
        description: 'Current building profile (debug/release/...)',
        example: 'debug',
    },
    VIM_INIFILE: {
        description: 'Full path name of current ini (.tasks) file',
        example: '',
    },
    VIM_INIHOME: {
        description: 'Where the ini file locates',
        example: '',
    },
};
async function genMacros() {
    const { nvim } = coc_nvim.workspace;
    ASYNCTASKS_MACROS.VIM_INIFILE.example = await nvim.call('expand', '%:p');
    ASYNCTASKS_MACROS.VIM_INIHOME.example = await nvim.call('expand', '%:p:h');
    return ASYNCTASKS_MACROS;
}

class TasksMacroCompletionProvider {
    async provideCompletionItems(document, position) {
        const prechar = document.getText({
            start: {
                line: position.line,
                character: position.character,
            },
            end: {
                line: position.line,
                character: position.character - 1,
            },
        });
        return Object.entries(await genMacros()).map((entry) => {
            const [macro, { description, example }] = entry;
            return {
                label: macro,
                kind: coc_nvim.CompletionItemKind.Constant,
                documentation: description + (example != '' ? `\ne.g. \`${example}\`` : ''),
                insertText: prechar == '$' ? `(${macro})` : macro,
            };
        });
    }
}

class TasksMacroHoverProvider {
    async provideHover(document, position) {
        const doc = coc_nvim.workspace.getDocument(document.uri);
        if (!doc)
            return null;
        const wordRange = doc.getWordRangeAtPosition(position);
        if (!wordRange)
            return null;
        const text = document.getText(wordRange) || '';
        if (!text)
            return null;
        const macros = await genMacros();
        if (!(text in macros))
            return null;
        const { description, example } = macros[text];
        const hover = {
            contents: {
                kind: 'markdown',
                value: description + (example != '' ? `\ne.g. \`${example}\`` : ''),
            },
        };
        return hover;
    }
}

class Tasks extends coc_nvim.BasicList {
    name = 'tasks';
    description = 'CocList for asynctasks.vim';
    defaultAction = 'run';
    actions = [];
    lastItem = null;
    constructor(nvim) {
        super(nvim);
        this.addLocationActions();
        this.addAction('run', (item) => {
            this.lastItem = item;
            this.nvim.command(`AsyncTask ${item.data.name}`, true);
        });
    }
    async runLastTask() {
        if (this.lastItem !== null) {
            await this.nvim.command(`AsyncTask ${this.lastItem.data.name}`, true);
        }
    }
    async loadItems(_context) {
        const source = [];
        const loaded_asynctasks = await this.nvim.eval('exists("*asynctasks#list")');
        if (loaded_asynctasks.valueOf() == 0)
            return [];
        const tasks = await this.nvim.call('asynctasks#list', ['']);
        for (const task of tasks) {
            if (/^\./.test(task.name))
                continue;
            source.push({
                label: `${task.name.padEnd(25)}` + `<${task.scope}>`.padEnd(10) + `:  ${task.command}`,
                data: task,
                filterText: task.name,
                location: coc_nvim.Uri.file(task.source).toString(),
            });
        }
        return source;
    }
    doHighlight() {
        const { nvim } = coc_nvim.workspace;
        nvim.pauseNotification();
        nvim.command('syntax match TaskName /^\\S\\+/', true);
        nvim.command('hi def link TaskName Constant', true);
        nvim.command('syn match TaskScope /\\s\\+<.*>\\s\\+:/', true);
        nvim.command('hi def link TaskScope Type', true);
        nvim.command('syn match TaskCommand /.*/ contains=TaskName,TaskScope', true);
        nvim.command('hi def link TaskCommand Comment', true);
        nvim.resumeNotification().catch((_e) => {
            // nop
        });
    }
}

async function activate(context) {
    const { nvim } = coc_nvim.workspace;
    const { subscriptions } = context;
    const config = coc_nvim.workspace.getConfiguration('tasks');
    const taskList = new Tasks(nvim);
    subscriptions.push(coc_nvim.listManager.registerList(taskList), coc_nvim.commands.registerCommand('tasks.runLastTask', async () => {
        await taskList.runLastTask();
    }));
    subscriptions.push(coc_nvim.languages.registerCompletionItemProvider('coc-tasks', config.get('shortcut'), config.get('filetypes'), new TasksMacroCompletionProvider(), config.get('triggerCharacters'), config.get('priority'), []));
    subscriptions.push(coc_nvim.languages.registerHoverProvider(config.get('filetypes'), new TasksMacroHoverProvider()));
}

exports.activate = activate;
